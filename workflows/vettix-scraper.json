{
  "name": "VetTix Scraper",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "vettix-scraper",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 0],
      "webhookId": "vettix-scraper"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://vettix-scraper.vettix-scraper.svc.cluster.local:8000/scrape",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ state: $json.body.state, status: $json.body.status || 'open' }) }}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "http-scrape",
      "name": "Scrape VetTix",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [220, 0]
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst webhookData = $('Webhook').first().json.body;\n\nif (!input.success) {\n  return [{\n    json: {\n      success: false,\n      error: true,\n      message: `Failed to scrape VetTix: ${input.message || 'Unknown error'}`\n    }\n  }];\n}\n\nconst events = input.events || [];\nconst state = input.state || webhookData.state?.toUpperCase() || 'Unknown';\nconst status = input.status || webhookData.status || 'open';\n\n// State name mapping\nconst stateNames = {\n  'TX': 'Texas', 'TN': 'Tennessee', 'CA': 'California', 'NV': 'Nevada',\n  'FL': 'Florida', 'NY': 'New York', 'AZ': 'Arizona', 'CO': 'Colorado',\n  'GA': 'Georgia', 'NC': 'North Carolina'\n};\nconst stateName = stateNames[state] || state;\n\n// Badge emoji mapping\nconst badgeEmojis = {\n  'BASKETBALL': 'üèÄ', 'FOOTBALL': 'üèà', 'CONCERTS': 'üéµ', 'COMEDY': 'üòÇ',\n  'HOCKEY': 'üèí', 'BASEBALL': '‚öæ', 'SOCCER': '‚öΩ', 'WRESTLING': 'ü§º',\n  'THEATER': 'üé≠', 'MUSICALS': 'üé≠', 'FAMILY': 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶', 'FESTIVALS/FAIRS': 'üé°',\n  'MONSTER TRUCK': 'üöö', 'ADULT': 'üîû', 'EDUCATIONAL': 'üìö',\n  'MAGICIAN/ILLUSIONIST': 'üé©', 'MIXED MARTIAL ARTS': 'ü•ä', 'SPORTS': 'üèÖ'\n};\n\n// Count events by category\nconst categoryCounts = {};\nfor (const event of events) {\n  const badge = event.badge || 'OTHER';\n  categoryCounts[badge] = (categoryCounts[badge] || 0) + 1;\n}\n\n// Sort categories by count\nconst sortedCategories = Object.entries(categoryCounts)\n  .sort((a, b) => b[1] - a[1])\n  .slice(0, 6);\n\n// Build category summary\nlet categoryText = '';\nfor (const [badge, count] of sortedCategories) {\n  const emoji = badgeEmojis[badge] || 'üì¶';\n  categoryText += `${emoji} ${badge}: ${count}\\n`;\n}\n\n// Get top 10 events\nconst topEvents = events.slice(0, 10);\n\n// Build embeds for top events\nconst embeds = topEvents.map(event => {\n  const emoji = badgeEmojis[event.badge] || 'üì¶';\n  return {\n    title: event.title,\n    description: `${emoji} **${event.badge}**\\nüìÖ ${event.date} at ${event.time}\\nüìç ${event.location}`,\n    url: event.link,\n    color: 0x00AA00,\n    footer: {\n      text: event.presented_by !== 'Unknown' ? event.presented_by : undefined\n    }\n  };\n});\n\n// Build summary message\nconst summary = `üìä **VetTix Events - ${stateName} (${state})**\\nFound **${events.length}** events with ${status} tickets\\n\\n**Categories:**\\n${categoryText}`;\n\nreturn [{\n  json: {\n    success: true,\n    state: state,\n    count: events.length,\n    message: summary,\n    embeds: embeds,\n    events: events,\n    guildId: webhookData.guild_id\n  }\n}];"
      },
      "id": "code-format",
      "name": "Format Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [440, 0]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "success-check",
              "leftValue": "={{ $json.success }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-success",
      "name": "Check Success?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [660, 0]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, state: $json.state, count: $json.count, message: $json.message, embeds: $json.embeds, events: $json.events }) }}",
        "options": {}
      },
      "id": "respond-success",
      "name": "Respond Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [880, -100]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": false,\n  \"error\": true,\n  \"message\": \"{{ $json.message || 'Failed to scrape VetTix events' }}\"\n}",
        "options": {}
      },
      "id": "respond-error",
      "name": "Respond Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [880, 100]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Scrape VetTix",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scrape VetTix": {
      "main": [
        [
          {
            "node": "Format Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Results": {
      "main": [
        [
          {
            "node": "Check Success?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Success?": {
      "main": [
        [
          {
            "node": "Respond Success",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
